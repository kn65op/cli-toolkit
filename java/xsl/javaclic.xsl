<?xml version="1.0" encoding="iso-8859-1"?>

<!--
    Copyright (c) 2006-2013, Alexis Royer, http://alexis.royer.free.fr/CLI

    All rights reserved.

    Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

        * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
        * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation
          and/or other materials provided with the distribution.
        * Neither the name of the CLI library project nor the names of its contributors may be used to endorse or promote products derived from this software
          without specific prior written permission.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
    CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
    LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->


<xsl:stylesheet
    version="1.0"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:cli="http://alexis.royer.free.fr/CLI">
<xsl:output method="text" encoding="iso-8859-1"/>


<!-- CLI class scope -->
<xsl:param name="STR_CliClassScope" select="''"/>
<!-- Variables prefix -->
<xsl:param name="STR_VarPrefix" select="'m_cli'"/>
<!-- Classes prefix -->
<xsl:param name="STR_ClassPrefix" select="''"/>
<!-- Indentation -->
<xsl:param name="STR_Indent" select="'    '"/>
<xsl:param name="STR_UserIndent" select="'/* &gt; */ '"/>
<!-- CLI class name -->
<xsl:param name="STR_CliClassName">
    <xsl:value-of select="$STR_ClassPrefix"/>
    <xsl:call-template name="T_MkJavaName">
        <xsl:with-param name="STR_String" select="/cli:cli/@name"/>
    </xsl:call-template>
</xsl:param>



<!-- Global variables -->
<xsl:variable name="STR_Endl"><xsl:text>
</xsl:text></xsl:variable>


<!-- Root template -->
<xsl:template match="/cli:cli">

    <!-- Head section -->
    <xsl:call-template name="T_ExtraJava">
        <xsl:with-param name="STR_Option" select="'head'"/>
    </xsl:call-template>
    <xsl:value-of select="$STR_Endl"/>

    <xsl:call-template name="T_Import"/>

    <!-- Import section -->
    <xsl:call-template name="T_ExtraJava">
        <xsl:with-param name="STR_Option" select="'import'"/>
    </xsl:call-template>
    <xsl:value-of select="$STR_Endl"/>

    <xsl:text>/**</xsl:text><xsl:value-of select="$STR_Endl"/>
    <xsl:text> * Class auto-generated by 'cli2java.xsl' - Do not edit!</xsl:text><xsl:value-of select="$STR_Endl"/>
    <!--<xsl:text> * File generated on </xsl:text><xsl:value-of select="date:date-time()"/><xsl:value-of select="$STR_Endl"/>-->
    <xsl:text> * @author cli2java.xsl - CLI library 2.8 (Alexis Royer, http://alexis.royer.free.fr/CLI/)</xsl:text><xsl:value-of select="$STR_Endl"/>
    <xsl:text> */</xsl:text><xsl:value-of select="$STR_Endl"/>
    <xsl:value-of select="$STR_Endl"/>

    <!-- Cli definition -->
    <xsl:call-template name="T_Menu"/><!-- [contrib: yuhuawen, 2011, Saxon / Xalan compliance] -->

    <!-- Tail section -->
    <xsl:call-template name="T_ExtraJava">
        <xsl:with-param name="STR_Option" select="'tail'"/>
    </xsl:call-template>
    <xsl:value-of select="$STR_Endl"/>

</xsl:template>


<xsl:template name="T_ExtraJava">
    <xsl:param name="STR_Option"/>

    <xsl:choose>
    <xsl:when test="$STR_Option='members'"><xsl:call-template name="T_Indent1"/></xsl:when>
    <xsl:when test="$STR_Option='constructor'"><xsl:call-template name="T_Indent2"/></xsl:when>
    <xsl:otherwise><xsl:call-template name="T_Indent0"/></xsl:otherwise>
    </xsl:choose>
        <xsl:text>// ----- Extra java (option='</xsl:text>
        <xsl:value-of select="$STR_Option"/>
        <xsl:text>') -----</xsl:text>
        <xsl:value-of select="$STR_Endl"/>

    <xsl:if test="cli:java[@option=$STR_Option] and ($STR_Option='members' or $STR_Option='constructor')">
        <xsl:value-of select="$STR_UserIndent"/><xsl:value-of select="$STR_Endl"/>
    </xsl:if>
    <xsl:for-each select="cli:java[@option=$STR_Option]">
        <xsl:choose>
        <xsl:when test="$STR_Option='members'"><xsl:call-template name="T_Indent1"><xsl:with-param name="STR_UserIndent" select="$STR_UserIndent"/></xsl:call-template></xsl:when>
        <xsl:when test="$STR_Option='constructor'"><xsl:call-template name="T_Indent2"><xsl:with-param name="STR_UserIndent" select="$STR_UserIndent"/></xsl:call-template></xsl:when>
        <xsl:otherwise><xsl:call-template name="T_Indent0"></xsl:call-template></xsl:otherwise>
        </xsl:choose>
            <xsl:apply-templates select="."/>
            <xsl:value-of select="$STR_Endl"/>
    </xsl:for-each>
    <xsl:if test="cli:java[@option=$STR_Option] and ($STR_Option='members' or $STR_Option='constructor')">
        <xsl:value-of select="$STR_UserIndent"/><xsl:value-of select="$STR_Endl"/>
    </xsl:if>

    <xsl:value-of select="$STR_Endl"/>
</xsl:template>

<xsl:template name="T_Import">
    <xsl:text>// ----- Imports -----</xsl:text><xsl:value-of select="$STR_Endl"/>
    <xsl:value-of select="$STR_Endl"/>
</xsl:template>

<xsl:template name="T_Menu">
    <xsl:variable name="STR_ClassName">
        <xsl:call-template name="T_Node2Class"/>
    </xsl:variable>
    <xsl:variable name="STR_SuperClass">
        <xsl:choose>
        <xsl:when test="self::cli:cli">cli.Cli</xsl:when>
        <xsl:otherwise>cli.Menu</xsl:otherwise>
        </xsl:choose>
    </xsl:variable>
    <xsl:variable name="STR_Scope">
        <xsl:choose>
        <xsl:when test="self::cli:cli"><xsl:value-of select="$STR_CliClassScope"/></xsl:when>
        <xsl:otherwise>private</xsl:otherwise>
        </xsl:choose>
    </xsl:variable>

    <xsl:if test="self::cli:cli">
        <xsl:call-template name="T_Indent0"/>
            <xsl:text>// ----- Cli class definition -----</xsl:text><xsl:value-of select="$STR_Endl"/>
    </xsl:if>
    <xsl:call-template name="T_Indent0"/>
        <xsl:value-of select="$STR_Scope"/><xsl:text> class </xsl:text><xsl:value-of select="$STR_ClassName"/>
        <xsl:text> extends </xsl:text><xsl:value-of select="$STR_SuperClass"/>
        <xsl:text> {</xsl:text><xsl:value-of select="$STR_Endl"/>

        <!-- Sub-menus at root only. -->
        <xsl:call-template name="T_MenuSubMenus"/>

        <!-- Node declarations. -->
        <xsl:call-template name="T_MenuMembers"/>

        <!-- Constructor -->
        <xsl:call-template name="T_MenuConstructor"/>

        <!-- Populating nodes. -->
        <xsl:call-template name="T_MenuPopulate"/>

        <!-- Menu implementation. -->
        <xsl:call-template name="T_MenuExecute"/>

        <!-- Menu handlers. -->
        <xsl:call-template name="T_MenuHandlers"/>

    <xsl:call-template name="T_Indent0"/>
        <xsl:text>}</xsl:text><xsl:value-of select="$STR_Endl"/>
    <xsl:if test="self::cli:cli">
        <xsl:value-of select="$STR_Endl"/>
    </xsl:if>

</xsl:template>

<xsl:template name="T_MenuSubMenus">
    <!-- Sub menus, only for CLI object -->
    <xsl:if test="self::cli:cli">
        <xsl:call-template name="T_Indent1"/>
            <xsl:text>// ----- Sub-menus -----</xsl:text>
            <xsl:value-of select="$STR_Endl"/>
        <xsl:for-each select=".//cli:menu[not(@ref)]">
            <xsl:call-template name="T_Menu"/>
            <xsl:value-of select="$STR_Endl"/>
        </xsl:for-each>
        <xsl:value-of select="$STR_Endl"/>
    </xsl:if>
    <!-- Any menu, reference to the owner CLI object -->
    <xsl:call-template name="T_Indent1"/>
        <xsl:text>// ----- Owner CLI -----</xsl:text>
        <xsl:value-of select="$STR_Endl"/>
    <xsl:call-template name="T_Indent1"/>
        <xsl:text>private </xsl:text>
        <xsl:for-each select="/cli:cli"><xsl:call-template name="T_Node2Class"/></xsl:for-each>
        <xsl:text> m_cliOwnerCli;</xsl:text>
        <xsl:value-of select="$STR_Endl"/>
</xsl:template>

<xsl:template name="T_MenuMembers">
    <xsl:variable name="STR_Class"><xsl:call-template name="T_Node2Class"/></xsl:variable>
    <xsl:variable name="STR_Var"><xsl:call-template name="T_Node2Var"/></xsl:variable>
    <xsl:variable name="I_IndentOffset"><xsl:call-template name="T_IndentOffset"/></xsl:variable>

    <!-- Menus -->
    <xsl:if test="self::cli:cli">
        <xsl:call-template name="T_Indent1"/>
            <xsl:text>// ----- Menus -----</xsl:text>
            <xsl:value-of select="$STR_Endl"/>
        <!-- Self -->
        <xsl:call-template name="T_DeclareNode">
            <xsl:with-param name="I_IndentCount" select="$I_IndentOffset + 1"/>
        </xsl:call-template>
        <!-- Effective menus -->
        <xsl:for-each select=".//cli:menu[@name]">
            <xsl:call-template name="T_DeclareNode">
                <xsl:with-param name="I_IndentCount" select="$I_IndentOffset + 1"/>
            </xsl:call-template>
        </xsl:for-each>
    </xsl:if>

    <!-- Sub-nodes -->
    <xsl:call-template name="T_Indent1"/>
        <xsl:text>// ----- Node members -----</xsl:text>
        <xsl:value-of select="$STR_Endl"/>
    <xsl:call-template name="T_DeclareSubNodes">
        <xsl:with-param name="I_IndentCount" select="$I_IndentOffset + 1"/>
    </xsl:call-template>

    <!-- Members section -->
    <xsl:call-template name="T_ExtraJava">
        <xsl:with-param name="STR_Option" select="'members'"/>
    </xsl:call-template>

    <xsl:value-of select="$STR_Endl"/>
</xsl:template>

    <xsl:template name="T_DeclareSubNodes">
        <xsl:param name="I_IndentCount" select="0"/>

        <xsl:for-each select="cli:*">
        <xsl:if test="  not(self::cli:help)
                        and not(self::cli:cpp)
                        and not(self::cli:java)
                        and not(self::cli:handler)
                        and not(self::cli:menu)
                        and not(self::cli:tag[@ref])">
            <xsl:call-template name="T_DeclareNode">
                <xsl:with-param name="I_IndentCount" select="$I_IndentCount"/>
            </xsl:call-template>
            <xsl:call-template name="T_DeclareSubNodes">
                <xsl:with-param name="I_IndentCount" select="$I_IndentCount + 1"/>
            </xsl:call-template>
        </xsl:if>
        </xsl:for-each>
    </xsl:template>

    <xsl:template name="T_DeclareNode">
        <xsl:param name="I_IndentCount" select="0"/>
        <xsl:param name="STR_Indent">
            <xsl:call-template name="T_Indent">
                <xsl:with-param name="I_IndentCount" select="$I_IndentCount"/>
            </xsl:call-template>
        </xsl:param>
        <xsl:variable name="STR_Class">
            <xsl:call-template name="T_Node2Class"/>
        </xsl:variable>
        <xsl:variable name="STR_Var">
            <xsl:call-template name="T_Node2Var">
                <xsl:with-param name="B_UseOwnerCli" select="0"/>
            </xsl:call-template>
        </xsl:variable>
        <xsl:variable name="STR_ParentVar">
            <xsl:for-each select="parent::cli:*">
                <xsl:call-template name="T_Node2Var"/>
            </xsl:for-each>
        </xsl:variable>

        <xsl:value-of select="$STR_Indent"/>
            <xsl:text>private </xsl:text>
            <xsl:value-of select="$STR_Class"/>
            <xsl:text> </xsl:text>
            <xsl:value-of select="$STR_Var"/>
            <xsl:text>;</xsl:text>
            <xsl:value-of select="$STR_Endl"/>

    </xsl:template>

<xsl:template name="T_MenuConstructor">
    <xsl:call-template name="T_Indent1"/>
        <xsl:text>// ----- Constructor -----</xsl:text>
        <xsl:value-of select="$STR_Endl"/>
    <xsl:call-template name="T_Indent1"/>
        <xsl:text>public </xsl:text>
        <xsl:call-template name="T_Node2Class"/>
        <xsl:text>() {</xsl:text>
        <xsl:value-of select="$STR_Endl"/>

        <!-- Initialization -->
        <xsl:call-template name="T_Indent2"/>
            <xsl:text>super(</xsl:text>
                <xsl:call-template name="T_CreateNodeParams"/>
            <xsl:text>);</xsl:text>
            <xsl:value-of select="$STR_Endl"/>
        <!-- Populate -->
        <xsl:if test="self::cli:cli">
            <xsl:call-template name="T_Indent2"/>
                <xsl:text>this.populate();</xsl:text>
                <xsl:value-of select="$STR_Endl"/>
        </xsl:if>
        <!-- Constructor section -->
        <xsl:call-template name="T_ExtraJava">
            <xsl:with-param name="STR_Option" select="'constructor'"/>
        </xsl:call-template>

    <xsl:call-template name="T_Indent1"/>
        <xsl:text>}</xsl:text><xsl:value-of select="$STR_Endl"/>
    <xsl:value-of select="$STR_Endl"/>
</xsl:template>

<xsl:template name="T_MenuPopulate">
    <xsl:variable name="STR_Class"><xsl:call-template name="T_Node2Class"/></xsl:variable>
    <xsl:variable name="STR_Var"><xsl:call-template name="T_Node2Var"/></xsl:variable>
    <xsl:variable name="I_IndentOffset"><xsl:call-template name="T_IndentOffset"/></xsl:variable>

    <xsl:call-template name="T_Indent1"/>
        <xsl:text>// ----- Populate -----</xsl:text>
        <xsl:value-of select="$STR_Endl"/>
    <xsl:call-template name="T_Indent1"/><xsl:text>public void populate() {</xsl:text><xsl:value-of select="$STR_Endl"/>

    <!-- CLI reference -->
    <xsl:call-template name="T_Indent2"/>
        <xsl:text>// CLI reference</xsl:text>
        <xsl:value-of select="$STR_Endl"/>
    <xsl:call-template name="T_Indent2"/>
        <xsl:text>m_cliOwnerCli = (</xsl:text>
        <xsl:for-each select="/cli:cli"><xsl:call-template name="T_Node2Class"/></xsl:for-each>
        <xsl:text>) getCli();</xsl:text>
        <xsl:value-of select="$STR_Endl"/>

    <!-- Populate menus -->
    <xsl:if test="self::cli:cli">
        <xsl:variable name="STR_Indent"><xsl:call-template name="T_Indent2"/></xsl:variable>

        <xsl:value-of select="$STR_Indent"/>
            <xsl:text>// Create menus and populate</xsl:text>
            <xsl:value-of select="$STR_Endl"/>
        <!-- Self CLI reference setting -->
        <xsl:value-of select="$STR_Indent"/>
            <xsl:call-template name="T_Node2Var"/>
            <xsl:text> = this;</xsl:text>
            <xsl:value-of select="$STR_Endl"/>
        <!-- Create the menus -->
        <xsl:for-each select=".//cli:menu[@name]">
            <xsl:value-of select="$STR_Indent"/>
                <xsl:call-template name="T_Node2Var"/>
                <xsl:text> = (</xsl:text>
                    <xsl:call-template name="T_Node2Class"/>
                <xsl:text>) </xsl:text>
                    <xsl:text>addMenu(</xsl:text>
                        <xsl:text>new </xsl:text><xsl:call-template name="T_Node2Class"/><xsl:text>()</xsl:text>
                    <xsl:text>);</xsl:text>
                <xsl:value-of select="$STR_Endl"/>
        </xsl:for-each>
        <!-- Populate them -->
        <xsl:for-each select=".//cli:menu[@name]">
            <xsl:value-of select="$STR_Indent"/>
                <xsl:call-template name="T_Node2Var"/>
                <xsl:text>.populate();</xsl:text>
                <xsl:value-of select="$STR_Endl"/>
        </xsl:for-each>
    </xsl:if>

    <!-- Sub-nodes -->
    <xsl:call-template name="T_Indent2"/>
        <xsl:text>// Local nodes</xsl:text>
        <xsl:value-of select="$STR_Endl"/>
    <xsl:call-template name="T_CreateSubNodes">
        <xsl:with-param name="I_IndentCount" select="$I_IndentOffset + 2"/>
    </xsl:call-template>
    <!-- tag[@ref] items are processed at the very end -->
    <xsl:variable name="xml_CurrentMenu" select="."/>
    <xsl:for-each select=".//cli:tag[@ref]">
    <xsl:if test="not(ancestor::cli:menu[@name and ancestor::cli:*[.=$xml_CurrentMenu]])">
        <xsl:call-template name="T_Indent"><xsl:with-param name="I_IndentCount" select="$I_IndentOffset + 2"/></xsl:call-template>
            <xsl:text>// tag[@ref] -> tag[@id] connections</xsl:text>
            <xsl:value-of select="$STR_Endl"/>
        <xsl:call-template name="T_CreateNode">
            <xsl:with-param name="I_IndentCount" select="$I_IndentOffset + 2"/>
        </xsl:call-template>
    </xsl:if>
    </xsl:for-each>

    <xsl:call-template name="T_Indent1"/><xsl:text>}</xsl:text><xsl:value-of select="$STR_Endl"/>
    <xsl:value-of select="$STR_Endl"/>
</xsl:template>

    <xsl:template name="T_CreateSubNodes">
        <xsl:param name="I_IndentCount" select="0"/>

        <!-- Then other nodes -->
        <xsl:for-each select="cli:*">
        <xsl:choose>
        <xsl:when test="self::cli:help"><!-- No population for help nodes. Help nodes generate help arguments. --></xsl:when>
        <xsl:when test="self::cli:cpp or self::cli:java or self::cli:handler"><!-- No population for target language nodes. --></xsl:when>
        <xsl:when test="self::cli:menu[@name] and parent::cli:cli"><!-- Do not populate menus which are defined at the cli level. --></xsl:when>
        <xsl:when test="self::cli:tag[@ref]"><!-- No population for tag[@ref] right now.
                                                  Because tag[@id] could be processed later, tag[@ref] will be processed at the very end,
                                                  in the T_CreateSubNodes template. --></xsl:when>
        <xsl:otherwise>
            <xsl:call-template name="T_CreateNode">
                <xsl:with-param name="I_IndentCount" select="$I_IndentCount"/>
            </xsl:call-template>
            <xsl:choose>
            <xsl:when test="self::cli:cli[@name]"><!-- Should never occure. --></xsl:when>
            <xsl:when test="self::cli:menu[@name]"><!-- Do not populate menus, this is done directly at the cli level. --></xsl:when>
            <xsl:otherwise>
                <xsl:call-template name="T_CreateSubNodes">
                    <xsl:with-param name="I_IndentCount" select="$I_IndentCount + 1"/>
                </xsl:call-template>
            </xsl:otherwise>
            </xsl:choose>
        </xsl:otherwise>
        </xsl:choose>
        </xsl:for-each>
    </xsl:template>

    <xsl:template name="T_CreateNode">
        <xsl:param name="I_IndentCount" select="0"/>
        <xsl:param name="B_WithCreateParams" select="1"/>
        <xsl:variable name="STR_Indent">
            <xsl:call-template name="T_Indent">
                <xsl:with-param name="I_IndentCount" select="$I_IndentCount"/>
            </xsl:call-template>
        </xsl:variable>
        <xsl:variable name="STR_Class">
            <xsl:call-template name="T_Node2Class"/>
        </xsl:variable>
        <xsl:variable name="STR_Var">
            <xsl:call-template name="T_Node2Var"/>
        </xsl:variable>
        <xsl:variable name="STR_ParentVar">
            <xsl:for-each select="parent::cli:*">
                <xsl:call-template name="T_Node2Var"/>
            </xsl:for-each>
        </xsl:variable>

        <xsl:value-of select="$STR_Indent"/>
            <xsl:if test="not(self::cli:tag[@ref]) and not(self::cli:menu)">
                <xsl:value-of select="$STR_Var"/>
                <xsl:text> = (</xsl:text>
                <xsl:value-of select="$STR_Class"/>
                <xsl:text>) </xsl:text>
            </xsl:if>
                <xsl:value-of select="$STR_ParentVar"/>
                <xsl:choose>
                <xsl:when test="self::cli:menu">
                    <xsl:text>.setMenuRef(</xsl:text>
                        <xsl:text>new cli.MenuRef(</xsl:text>
                            <xsl:choose>
                            <xsl:when test="self::cli:menu[@name]">
                                <xsl:call-template name="T_Node2Var"/>
                            </xsl:when>
                            <xsl:when test="self::cli:menu[@ref]">
                                <xsl:variable name="STR_MenuId" select="@ref"/>
                                <xsl:variable name="STR_MenuRef">
                                    <xsl:for-each select="//cli:menu[@name=$STR_MenuId]">
                                        <xsl:call-template name="T_Node2Var"/>
                                    </xsl:for-each>
                                </xsl:variable>
                                <xsl:if test="string-length($STR_MenuRef) = 0">
                                    <xsl:call-template name="T_Error">
                                        <xsl:with-param name="STR_Message"><xsl:text>No such menu '</xsl:text><xsl:value-of select="$STR_MenuId"/><xsl:text>'</xsl:text></xsl:with-param>
                                    </xsl:call-template>
                                </xsl:if>
                                <xsl:value-of select="$STR_MenuRef"/>
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:call-template name="T_Error">
                                    <xsl:with-param name="STR_Message">missing menu/@name or menu/@ref attribute</xsl:with-param>
                                </xsl:call-template>
                            </xsl:otherwise>
                            </xsl:choose>
                        <xsl:text>)</xsl:text>
                    <xsl:text>)</xsl:text>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:text>.addElement(</xsl:text>
                        <xsl:text>new </xsl:text><xsl:value-of select="$STR_Class"/><xsl:text>(</xsl:text>
                            <xsl:if test="$B_WithCreateParams">
                                <xsl:call-template name="T_CreateNodeParams"/>
                            </xsl:if>
                        <xsl:text>)</xsl:text>
                    <xsl:text>)</xsl:text>
                </xsl:otherwise>
                </xsl:choose>
            <xsl:text>;</xsl:text>
            <xsl:value-of select="$STR_Endl"/>

    </xsl:template>

    <xsl:template name="T_CreateNodeParams">
        <xsl:variable name="STR_ElementRef">
            <xsl:choose>
            <xsl:when test="self::cli:tag[@ref]">
                <xsl:variable name="STR_TagId" select="@ref"/>
                <xsl:variable name="STR_TagRef">
                    <xsl:for-each select="//cli:tag[@id=$STR_TagId]">
                        <xsl:call-template name="T_Node2Var"/>
                    </xsl:for-each>
                </xsl:variable>
                <xsl:if test="string-length($STR_TagRef) = 0">
                    <xsl:call-template name="T_Error">
                        <xsl:with-param name="STR_Message"><xsl:text>No such tag identifier '</xsl:text><xsl:value-of select="$STR_TagId"/><xsl:text>'</xsl:text></xsl:with-param>
                    </xsl:call-template>
                </xsl:if>
                <xsl:value-of select="$STR_TagRef"/>
            </xsl:when>
            <xsl:when test="self::cli:menu[@ref]">
                <xsl:variable name="STR_MenuId" select="@ref"/>
                <xsl:variable name="STR_MenuRef">
                    <xsl:for-each select="//cli:menu[@name=$STR_MenuId]">
                        <xsl:call-template name="T_Node2Var"/>
                    </xsl:for-each>
                </xsl:variable>
                <xsl:if test="string-length($STR_MenuRef) = 0">
                    <xsl:call-template name="T_Error">
                        <xsl:with-param name="STR_Message"><xsl:text>No such menu '</xsl:text><xsl:value-of select="$STR_MenuId"/><xsl:text>'</xsl:text></xsl:with-param>
                    </xsl:call-template>
                </xsl:if>
                <xsl:value-of select="$STR_MenuRef"/>
            </xsl:when>
            </xsl:choose>
            </xsl:variable>
        <xsl:variable name="B_ElementRef" select="string-length($STR_ElementRef)"/>
        <xsl:variable name="STR_Keyword">
            <xsl:choose>
            <xsl:when test="self::cli:cli or self::cli:menu">
                <xsl:value-of select="@name"/>
            </xsl:when>
            <xsl:when test="self::cli:keyword">
                <xsl:value-of select="@string"/>
            </xsl:when>
            </xsl:choose>
        </xsl:variable>
        <xsl:variable name="B_Keyword" select="string-length($STR_Keyword)"/>
        <xsl:variable name="B_Help">
            <xsl:choose>
            <xsl:when test="self::cli:tag">0</xsl:when>
            <xsl:when test="self::cli:menu[@ref]">0</xsl:when>
            <xsl:otherwise>1</xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:choose>
        <xsl:when test="self::cli:tag[@id and @hollow='yes']">
            <xsl:text>true</xsl:text>
        </xsl:when>
        <xsl:when test="self::cli:tag[@id]">
            <xsl:text>false</xsl:text>
        </xsl:when>
        <xsl:when test="not($B_ElementRef=0)">
            <xsl:value-of select="$STR_ElementRef"/>
        </xsl:when>
        <xsl:otherwise>
            <xsl:if test="not($B_Keyword=0)">
                <xsl:text>"</xsl:text>
                <xsl:value-of select="$STR_Keyword"/>
                <xsl:text>"</xsl:text>
            </xsl:if>
            <xsl:if test="$B_Keyword and $B_Help">
                <xsl:text>, </xsl:text>
            </xsl:if>
            <xsl:if test="not($B_Help=0)">
                <xsl:text>new cli.Help()</xsl:text>
                <xsl:for-each select="cli:help">
                    <xsl:variable name="STR_Lang">
                        <xsl:choose>
                        <xsl:when test="@lang='en'">
                            <xsl:text>cli.Help.LANG_EN</xsl:text>
                        </xsl:when>
                        <xsl:when test="@lang='fr'">
                            <xsl:text>cli.Help.LANG_FR</xsl:text>
                        </xsl:when>
                        </xsl:choose>
                    </xsl:variable>

                    <xsl:if test="string-length($STR_Lang) &gt; 0">
                        <xsl:text>.addHelp(</xsl:text>
                            <xsl:value-of select="$STR_Lang"/>
                            <xsl:text>, </xsl:text>
                            <xsl:text>"</xsl:text>
                            <xsl:value-of select="."/>
                            <xsl:text>"</xsl:text>
                        <xsl:text>)</xsl:text>
                    </xsl:if>
                </xsl:for-each>
            </xsl:if>
        </xsl:otherwise>
        </xsl:choose>
    </xsl:template>


<xsl:template name="T_MenuExecute">
    <xsl:call-template name="T_Indent1"/>
        <xsl:text>// ----- Menu execution -----</xsl:text>
        <xsl:value-of select="$STR_Endl"/>

    <xsl:call-template name="T_ImplementMenu"/>

    <!--<xsl:value-of select="$STR_Endl"/>-->
</xsl:template>

    <xsl:template name="T_ImplementMenu">
        <xsl:variable name="STR_Class">
            <xsl:call-template name="T_Node2Class"/>
        </xsl:variable>
        <xsl:variable name="I_IndentOffset">
            <xsl:call-template name="T_IndentOffset"/>
        </xsl:variable>

        <!-- Execution method -->
        <xsl:call-template name="T_Indent1"/>
        <xsl:text>public boolean execute(cli.CommandLine CLI_CmdLine) {</xsl:text>
            <xsl:value-of select="$STR_Endl"/>

            <xsl:call-template name="T_Indent2"/>
                <xsl:text>try {</xsl:text>
                <xsl:value-of select="$STR_Endl"/>

            <!-- Trace -->
            <xsl:call-template name="T_Indent3"/>
                <xsl:text>cli.TraceClass CLI_EXECUTION = new cli.TraceClass(</xsl:text>
                    <xsl:text>"CLI_EXECUTION", </xsl:text>
                    <xsl:text>new cli.Help()</xsl:text>
                        <xsl:text>.addHelp(cli.Help.LANG_EN, "CLI Execution traces")</xsl:text>
                        <xsl:text>.addHelp(cli.Help.LANG_FR, "Traces d'exécution du CLI")</xsl:text>
                <xsl:text>);</xsl:text>
                <xsl:value-of select="$STR_Endl"/>

            <!-- Step variables -->
            <xsl:call-template name="T_Indent3"/>
                <xsl:text>java.util.Iterator&lt;cli.Element&gt; cli_Elements = CLI_CmdLine.iterator();</xsl:text>
                <xsl:value-of select="$STR_Endl"/>
            <xsl:call-template name="T_Indent3"/>
                <xsl:text>cli.Element cli_Element = null;</xsl:text>
                <xsl:value-of select="$STR_Endl"/>

            <!-- Call implementation on the menu object -->
            <xsl:call-template name="T_ImplementMenuExecution">
                <xsl:with-param name="I_IndentCount" select="$I_IndentOffset + 3"/>
            </xsl:call-template>

            <!-- Finishing -->
            <xsl:call-template name="T_Indent2"/>
                <xsl:text>} catch (java.util.NoSuchElementException e1) {</xsl:text>
                <xsl:value-of select="$STR_Endl"/>
            <!--<xsl:call-template name="T_Indent3"/>
                <xsl:text>getErrorStream().printStackTrace(e1);</xsl:text>
                <xsl:value-of select="$STR_Endl"/>-->
            <xsl:call-template name="T_Indent2"/>
                <xsl:text>} catch (java.lang.Exception e) {</xsl:text>
                <xsl:value-of select="$STR_Endl"/>
            <xsl:call-template name="T_Indent3"/>
                <xsl:text>getErrorStream().printStackTrace(e);</xsl:text>
                <xsl:value-of select="$STR_Endl"/>
            <xsl:call-template name="T_Indent2"/>
                <xsl:text>}</xsl:text>
                <xsl:value-of select="$STR_Endl"/>
            <xsl:call-template name="T_Indent2"/>
                <xsl:text>return false;</xsl:text>
                <xsl:value-of select="$STR_Endl"/>

        <xsl:call-template name="T_Indent1"/>
            <xsl:text>}</xsl:text>
            <xsl:value-of select="$STR_Endl"/>
        <xsl:value-of select="$STR_Endl"/>
    </xsl:template>

    <xsl:template name="T_ImplementMenuExecution">
        <xsl:param name="I_IndentCount" select="0"/>
        <xsl:variable name="STR_Indent0">
            <xsl:call-template name="T_Indent">
                <xsl:with-param name="I_IndentCount" select="$I_IndentCount + 0"/>
            </xsl:call-template>
        </xsl:variable>
        <xsl:variable name="STR_Indent1">
            <xsl:call-template name="T_Indent">
                <xsl:with-param name="I_IndentCount" select="$I_IndentCount + 1"/>
            </xsl:call-template>
        </xsl:variable>
        <xsl:variable name="STR_Indent2">
            <xsl:call-template name="T_Indent">
                <xsl:with-param name="I_IndentCount" select="$I_IndentCount + 2"/>
            </xsl:call-template>
        </xsl:variable>

        <!-- Top comment -->
        <xsl:value-of select="$STR_Indent0"/>
            <xsl:text>// </xsl:text>
            <xsl:call-template name="T_Node2Desc"/>
            <xsl:value-of select="$STR_Endl"/>

        <!-- Block label -->
        <xsl:choose>
        <xsl:when test="self::cli:tag[@id]">
            <xsl:value-of select="$STR_Indent0"/>
                <xsl:call-template name="T_Node2BlockLabel"/>
                <xsl:text>:</xsl:text>
                <xsl:value-of select="$STR_Endl"/>
        </xsl:when>
        <xsl:when test="self::cli:param">
            <xsl:value-of select="$STR_Indent0"/>
                <xsl:call-template name="T_Node2BlockLabel"/>
                <xsl:text>:</xsl:text>
                <xsl:value-of select="$STR_Endl"/>
        </xsl:when>
        <xsl:otherwise>
            <xsl:value-of select="$STR_Indent0"/>
                <xsl:call-template name="T_Node2BlockLabel"/>
                <xsl:text>:</xsl:text>
                <xsl:value-of select="$STR_Endl"/>
        </xsl:otherwise>
        </xsl:choose>

        <!-- Start the block -->
        <xsl:choose>
        <xsl:when test="self::cli:cli or self::cli:menu or self::cli:tag[@ref]">
            <xsl:value-of select="$STR_Indent0"/>
            <xsl:text>{</xsl:text>
                <xsl:value-of select="$STR_Endl"/>
        </xsl:when>
        <xsl:when test="self::cli:tag[@id]">
            <xsl:value-of select="$STR_Indent0"/>
            <xsl:text>do {</xsl:text>
                <xsl:value-of select="$STR_Endl"/>
        </xsl:when>
        <xsl:when test="self::cli:param">
            <xsl:value-of select="$STR_Indent0"/>
            <xsl:text>if (</xsl:text><xsl:call-template name="T_Node2Var"/><xsl:text>.matches(cli_Element)</xsl:text><xsl:text>) {</xsl:text>
                <xsl:value-of select="$STR_Endl"/>
        </xsl:when>
        <xsl:otherwise>
            <xsl:value-of select="$STR_Indent0"/>
            <xsl:text>if (cli_Element == </xsl:text><xsl:call-template name="T_Node2Var"/><xsl:text>) {</xsl:text>
                <xsl:value-of select="$STR_Endl"/>
        </xsl:otherwise>
        </xsl:choose>

        <!-- Step it -->
        <xsl:if test="not(self::cli:tag or self::cli:endl)">
            <xsl:value-of select="$STR_Indent1"/>
                <xsl:text>cli_Element = cli_Elements.next();</xsl:text>
                <xsl:value-of select="$STR_Endl"/>
            <xsl:value-of select="$STR_Indent1"/>
                <xsl:text>if (cli_Element == null) return false;</xsl:text>
                <xsl:value-of select="$STR_Endl"/>
        </xsl:if>

        <!-- Trace current keyword -->
        <xsl:value-of select="$STR_Indent1"/>
            <xsl:text>cli.Traces.trace(CLI_EXECUTION, </xsl:text>
            <xsl:text>"context = \"</xsl:text><xsl:call-template name="T_Node2Desc"/><xsl:text>\", "</xsl:text>
            <xsl:text>+ "word = " + (cli_Element instanceof cli.Endl ? "&lt;CR&gt;" : cli_Element.getKeyword()));</xsl:text>
            <xsl:value-of select="$STR_Endl"/>

        <!-- Execution -->
        <xsl:if test="count(cli:java[not(@*)]) &gt; 0">
            <xsl:value-of select="$STR_UserIndent"/><xsl:value-of select="$STR_Endl"/>
            <xsl:for-each select="cli:java[not(@*)]">
                <xsl:call-template name="T_Indent">
                    <xsl:with-param name="STR_UserIndent" select="$STR_UserIndent"/>
                    <xsl:with-param name="I_IndentCount" select="$I_IndentCount + 1"/>
                </xsl:call-template>
                    <xsl:apply-templates select="."/>
                    <xsl:value-of select="$STR_Endl"/>
            </xsl:for-each>
            <xsl:value-of select="$STR_UserIndent"/><xsl:value-of select="$STR_Endl"/>
        </xsl:if>

        <!-- Sub-elements -->
        <xsl:call-template name="T_SubElements">
            <xsl:with-param name="I_IndentCount" select="$I_IndentCount + 1"/>
        </xsl:call-template>

        <!-- Final jump -->
        <xsl:choose>
        <xsl:when test="self::cli:tag[@id]">
            <xsl:value-of select="$STR_Indent1"/>
                <xsl:text>break </xsl:text>
                <xsl:call-template name="T_Node2BlockLabel"/>
                <xsl:text>;</xsl:text>
                <xsl:value-of select="$STR_Endl"/>
        </xsl:when>
        <xsl:when test="self::cli:tag[@ref]"></xsl:when>
        <xsl:when test="self::cli:endl"></xsl:when>
        <xsl:otherwise>
            <xsl:value-of select="$STR_Indent1"/>
                <xsl:text>return false;</xsl:text>
                <xsl:value-of select="$STR_Endl"/>
        </xsl:otherwise>
        </xsl:choose>

        <!-- End the block -->
        <xsl:choose>
        <xsl:when test="self::cli:tag[@id]">
            <xsl:value-of select="$STR_Indent0"/>
                <xsl:text>} while(true);</xsl:text>
                <xsl:value-of select="$STR_Endl"/>
        </xsl:when>
        <xsl:otherwise>
            <xsl:value-of select="$STR_Indent0"/>
                <xsl:text>}</xsl:text>
                <xsl:value-of select="$STR_Endl"/>
        </xsl:otherwise>
        </xsl:choose>

    </xsl:template>

    <xsl:template name="T_SubElements">
        <xsl:param name="I_IndentCount" select="0"/>
        <xsl:param name="XML_JumpTag"/>

        <xsl:variable name="STR_Indent">
            <xsl:call-template name="T_Indent">
                <xsl:with-param name="I_IndentCount" select="$I_IndentCount"/>
            </xsl:call-template>
        </xsl:variable>

        <xsl:choose>
        <xsl:when test="self::cli:endl">
            <xsl:value-of select="$STR_Indent"/>
                <xsl:text>return true;</xsl:text>
                <xsl:value-of select="$STR_Endl"/>
        </xsl:when>
        <xsl:when test="self::cli:tag[@ref]">
            <xsl:variable name="STR_Tag" select="@ref"/>

            <xsl:choose>
            <xsl:when test="parent::cli:tag[@id=$STR_Tag]">
                <xsl:call-template name="T_Error">
                    <xsl:with-param name="STR_Message">tag reference '<xsl:value-of select="$STR_Tag"/>' directly located in the tag</xsl:with-param>
                </xsl:call-template>
            </xsl:when>
            <xsl:when test="ancestor::cli:tag[@id=$STR_Tag]">
                <!-- The referenced tag is an ancestor -->
                <!-- Use a 'continue' statement to avoid inifinite loop generations -->
                <xsl:for-each select="ancestor::cli:tag[@id=$STR_Tag]">
                    <xsl:choose>
                    <xsl:when test="$XML_JumpTag">
                        <xsl:call-template name="T_SubElements">
                            <xsl:with-param name="I_IndentCount" select="$I_IndentCount"/>
                            <xsl:with-param name="XML_JumpTag" select="$XML_JumpTag"/>
                        </xsl:call-template>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:call-template name="T_SubElements">
                            <xsl:with-param name="I_IndentCount" select="$I_IndentCount"/>
                            <xsl:with-param name="XML_JumpTag" select="."/>
                        </xsl:call-template>
                    </xsl:otherwise>
                    </xsl:choose>
                </xsl:for-each>
            </xsl:when>
            <xsl:otherwise>
                <!-- The referenced tag is not an ancestor -->
                <!-- Implementation is required here -->
                <xsl:for-each select="//cli:tag[@id=$STR_Tag]">
                    <xsl:call-template name="T_SubElements">
                        <xsl:with-param name="I_IndentCount" select="$I_IndentCount"/>
                        <xsl:with-param name="XML_JumpTag"/>
                    </xsl:call-template>
                </xsl:for-each>
            </xsl:otherwise>
            </xsl:choose>
        </xsl:when>
        <xsl:otherwise>
            <xsl:for-each select="cli:keyword|cli:param|cli:tag[not(@hollow='yes')]|cli:endl">
                <xsl:choose>
                <xsl:when test="not($XML_JumpTag)">
                    <xsl:call-template name="T_ImplementMenuExecution">
                        <xsl:with-param name="I_IndentCount" select="$I_IndentCount"/>
                    </xsl:call-template>
                </xsl:when>
                <xsl:when test="$XML_JumpTag">
                    <xsl:variable name="STR_JumpLabel"><xsl:for-each select="$XML_JumpTag"><xsl:call-template name="T_Node2BlockLabel"/></xsl:for-each></xsl:variable>

                    <xsl:choose>
                    <xsl:when test="self::cli:tag[@ref]">
                        <xsl:call-template name="T_SubElements">
                            <xsl:with-param name="I_IndentCount" select="$I_IndentCount"/>
                            <xsl:with-param name="XML_JumpTag" select="$XML_JumpTag"/>
                        </xsl:call-template>
                    </xsl:when>
                    <xsl:when test="self::cli:tag[@hollow='yes']"><!-- Do nothing --></xsl:when>
                    <xsl:when test="self::cli:tag[@id]">
                        <xsl:call-template name="T_SubElements">
                            <xsl:with-param name="I_IndentCount" select="$I_IndentCount"/>
                            <xsl:with-param name="XML_JumpTag" select="$XML_JumpTag"/>
                        </xsl:call-template>
                    </xsl:when>
                    <xsl:when test="self::cli:param">
                        <xsl:value-of select="$STR_Indent"/>
                            <xsl:text>if (</xsl:text><xsl:call-template name="T_Node2Var"/><xsl:text>.matches(cli_Element)</xsl:text><xsl:text>) </xsl:text>
                            <xsl:text>continue </xsl:text><xsl:value-of select="$STR_JumpLabel"/><xsl:text>;</xsl:text><xsl:value-of select="$STR_Endl"/>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:value-of select="$STR_Indent"/>
                            <xsl:text>if (</xsl:text><xsl:text>cli_Element == </xsl:text><xsl:call-template name="T_Node2Var"/><xsl:text>) </xsl:text>
                            <xsl:text>continue </xsl:text><xsl:value-of select="$STR_JumpLabel"/><xsl:text>;</xsl:text><xsl:value-of select="$STR_Endl"/>
                    </xsl:otherwise>
                    </xsl:choose>
                </xsl:when>
                </xsl:choose>
            </xsl:for-each>
        </xsl:otherwise>
        </xsl:choose>

    </xsl:template>

    <xsl:template name="T_MenuHandlers">
        <xsl:variable name="STR_Class"><xsl:call-template name="T_Node2Class"/></xsl:variable>

        <!-- Error handler -->
        <xsl:if test="self::cli:cli and cli:handler[@name='error']/cli:java">
            <xsl:call-template name="T_Indent1"/>
                <xsl:text>public boolean onError(cli.ResourceString location, cli.ResourceString message) {</xsl:text>
                <xsl:value-of select="$STR_Endl"/>
            <xsl:for-each select="cli:handler[@name='error']">
                <xsl:if test="cli:java"><xsl:value-of select="$STR_UserIndent"/><xsl:value-of select="$STR_Endl"/></xsl:if>
                <xsl:for-each select="cli:java">
                    <xsl:call-template name="T_Indent2"><xsl:with-param name="STR_UserIndent" select="$STR_UserIndent"/></xsl:call-template>
                        <xsl:apply-templates select="."/>
                        <xsl:value-of select="$STR_Endl"/>
                </xsl:for-each>
                <xsl:if test="cli:java"><xsl:value-of select="$STR_UserIndent"/><xsl:value-of select="$STR_Endl"/></xsl:if>
            </xsl:for-each>
            <xsl:if test="not(cli:handler[@name='error']/cli:java[contains(.,'return')])">
                <xsl:call-template name="T_Indent2"/>
                    <xsl:text>return super.onError(location, message);</xsl:text>
                    <xsl:value-of select="$STR_Endl"/>
            </xsl:if>
            <xsl:call-template name="T_Indent1"/>
                <xsl:text>}</xsl:text>
                <xsl:value-of select="$STR_Endl"/>
            <xsl:value-of select="$STR_Endl"/>
        </xsl:if>

        <!-- Exit handler -->
        <xsl:call-template name="T_Indent1"/>
            <xsl:text>public void onExit() {</xsl:text>
            <xsl:value-of select="$STR_Endl"/>
        <xsl:for-each select="cli:handler[@name='exit']">
            <xsl:if test="cli:java"><xsl:value-of select="$STR_UserIndent"/><xsl:value-of select="$STR_Endl"/></xsl:if>
            <xsl:for-each select="cli:java">
                <xsl:call-template name="T_Indent2"><xsl:with-param name="STR_UserIndent" select="$STR_UserIndent"/></xsl:call-template>
                    <xsl:apply-templates select="."/>
                    <xsl:value-of select="$STR_Endl"/>
            </xsl:for-each>
            <xsl:if test="cli:java"><xsl:value-of select="$STR_UserIndent"/><xsl:value-of select="$STR_Endl"/></xsl:if>
        </xsl:for-each>
        <xsl:call-template name="T_Indent1"/>
            <xsl:text>}</xsl:text>
            <xsl:value-of select="$STR_Endl"/>
        <xsl:value-of select="$STR_Endl"/>

        <!-- Prompt handler -->
        <xsl:call-template name="T_Indent1"/>
            <xsl:text>public java.lang.String onPrompt() {</xsl:text>
            <xsl:value-of select="$STR_Endl"/>
        <xsl:for-each select="cli:handler[@name='prompt']">
            <xsl:if test="cli:java"><xsl:value-of select="$STR_UserIndent"/><xsl:value-of select="$STR_Endl"/></xsl:if>
            <xsl:for-each select="cli:java">
                <xsl:call-template name="T_Indent2"><xsl:with-param name="STR_UserIndent" select="$STR_UserIndent"/></xsl:call-template>
                    <xsl:apply-templates select="."/>
                    <xsl:value-of select="$STR_Endl"/>
            </xsl:for-each>
            <xsl:if test="cli:java"><xsl:value-of select="$STR_UserIndent"/><xsl:value-of select="$STR_Endl"/></xsl:if>
        </xsl:for-each>
        <xsl:if test="not(cli:handler[@name='prompt']/cli:java[contains(.,'return')])">
            <xsl:call-template name="T_Indent2"/>
                <xsl:text>return super.onPrompt();</xsl:text>
                <xsl:value-of select="$STR_Endl"/>
        </xsl:if>
        <xsl:call-template name="T_Indent1"/>
            <xsl:text>}</xsl:text>
            <xsl:value-of select="$STR_Endl"/>
        <xsl:value-of select="$STR_Endl"/>
    </xsl:template>

<xsl:template name="T_Node2Desc">
    <!-- Recursive call -->
    <xsl:if test="not(self::cli:cli) and not(self::cli:menu[@name])">
        <xsl:for-each select="parent::cli:*">
            <xsl:call-template name="T_Node2Desc"/>
        </xsl:for-each>
        <xsl:text> </xsl:text>
    </xsl:if>

    <!-- Current item description -->
    <xsl:choose>
    <xsl:when test="self::cli:cli"><xsl:value-of select="@name"/><xsl:text>&gt;</xsl:text></xsl:when>
    <xsl:when test="self::cli:menu[@name]"><xsl:value-of select="@name"/><xsl:text>&gt;</xsl:text></xsl:when>
    <xsl:when test="self::cli:keyword"><xsl:value-of select="@string"/></xsl:when>
    <xsl:when test="self::cli:param"><xsl:text>$</xsl:text><xsl:value-of select="@id"/></xsl:when>
    <xsl:when test="self::cli:tag[@id]"><xsl:text>[</xsl:text><xsl:value-of select="@id"/><xsl:text>:]</xsl:text></xsl:when>
    <xsl:when test="self::cli:tag[@ref]"><xsl:text>[-&gt; </xsl:text><xsl:value-of select="@ref"/><xsl:text>]</xsl:text></xsl:when>
    <xsl:when test="self::cli:endl"><xsl:text>&lt;CR&gt;</xsl:text></xsl:when>
    <xsl:otherwise><xsl:text>???</xsl:text></xsl:otherwise>
    </xsl:choose>
</xsl:template>

<xsl:template name="T_Node2Var">
    <xsl:param name="B_UseOwnerCli" select="1"/>
    <xsl:variable name="STR_NodeName" select="local-name(.)"/>

    <!-- Menu: access through the m_pcliOwnerCli member. -->
    <xsl:if test="(self::cli:cli or self::cli:menu[@name]) and $B_UseOwnerCli">
        <xsl:text>m_cliOwnerCli.</xsl:text>
    </xsl:if>

    <!-- variable prefix -->
    <xsl:value-of select="$STR_VarPrefix"/>

    <!-- element type -->
    <xsl:choose>
    <xsl:when test="self::cli:tag[@ref]"><xsl:text>tagref</xsl:text></xsl:when>
    <xsl:when test="self::cli:menu[@ref]"><xsl:text>menuref</xsl:text></xsl:when>
    <xsl:otherwise>
        <xsl:call-template name="T_MkJavaName">
            <xsl:with-param name="STR_String" select="local-name(.)"/>
        </xsl:call-template>
    </xsl:otherwise>
    </xsl:choose>

    <!-- element name -->
    <xsl:choose>
    <xsl:when test="self::cli:keyword">
        <xsl:text>_</xsl:text>
        <xsl:call-template name="T_MkJavaName">
            <xsl:with-param name="STR_String" select="@string"/>
        </xsl:call-template>
    </xsl:when>
    <xsl:when test="self::cli:param">
        <xsl:text>_</xsl:text>
        <xsl:call-template name="T_MkJavaName">
            <xsl:with-param name="STR_String" select="@id"/>
        </xsl:call-template>
    </xsl:when>
    </xsl:choose>

    <!-- id -->
    <xsl:text>_</xsl:text>
    <xsl:call-template name="T_Node2Id"/>
</xsl:template>
<xsl:template name="T_Node2Id">
    <xsl:param name="STR_Separator" select="''"/>
    <xsl:variable name="I_Count" select="count(preceding-sibling::cli:*)"/>

    <!-- Recursive call -->
    <xsl:if test="parent::cli:* and not(parent::cli:cli)">
        <xsl:for-each select="parent::cli:*">
            <xsl:call-template name="T_Node2Id">
                <xsl:with-param name="STR_Separator"><xsl:if test="$I_Count &gt;= 26+26"><xsl:text>_</xsl:text></xsl:if></xsl:with-param>
            </xsl:call-template>
        </xsl:for-each>
    </xsl:if>
    <!-- Generate id part based on the position of the node regarding its preceding-sibling.
         Start with a,b,c...x,y,z,A,B,C...X,Y,Z, then numbers from 0 seperated with '_' if numbers follow each others. -->
    <xsl:choose>
        <xsl:when test="$I_Count = 0"><xsl:text>a</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 1"><xsl:text>b</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 2"><xsl:text>c</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 3"><xsl:text>d</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 4"><xsl:text>e</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 5"><xsl:text>f</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 6"><xsl:text>g</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 7"><xsl:text>h</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 8"><xsl:text>i</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 9"><xsl:text>j</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 10"><xsl:text>k</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 11"><xsl:text>l</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 12"><xsl:text>m</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 13"><xsl:text>n</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 14"><xsl:text>o</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 15"><xsl:text>p</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 16"><xsl:text>q</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 17"><xsl:text>r</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 18"><xsl:text>s</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 19"><xsl:text>t</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 20"><xsl:text>u</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 21"><xsl:text>v</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 22"><xsl:text>w</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 23"><xsl:text>x</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 24"><xsl:text>y</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 25"><xsl:text>z</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 26+0"><xsl:text>A</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 26+1"><xsl:text>B</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 26+2"><xsl:text>C</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 26+3"><xsl:text>D</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 26+4"><xsl:text>E</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 26+5"><xsl:text>F</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 26+6"><xsl:text>G</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 26+7"><xsl:text>H</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 26+8"><xsl:text>I</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 26+9"><xsl:text>J</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 26+10"><xsl:text>K</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 26+11"><xsl:text>L</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 26+12"><xsl:text>M</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 26+13"><xsl:text>N</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 26+14"><xsl:text>O</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 26+15"><xsl:text>P</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 26+16"><xsl:text>Q</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 26+17"><xsl:text>R</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 26+18"><xsl:text>S</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 26+19"><xsl:text>T</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 26+20"><xsl:text>U</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 26+21"><xsl:text>V</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 26+22"><xsl:text>W</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 26+23"><xsl:text>X</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 26+24"><xsl:text>Y</xsl:text></xsl:when>
        <xsl:when test="$I_Count = 26+25"><xsl:text>Z</xsl:text></xsl:when>
        <xsl:otherwise><xsl:value-of select="number($I_Count)-26-26"/><xsl:value-of select="$STR_Separator"/></xsl:otherwise>
    </xsl:choose>
</xsl:template>

<xsl:template name="T_Node2Class">
    <xsl:choose>
    <xsl:when test="self::cli:cli">
        <xsl:value-of select="$STR_CliClassName"/>
    </xsl:when>
    <xsl:when test="self::cli:menu[@name]">
        <xsl:value-of select="$STR_ClassPrefix"/>
        <xsl:call-template name="T_MkJavaName">
            <xsl:with-param name="STR_String" select="@name"/>
        </xsl:call-template>
    </xsl:when>
    <xsl:when test="self::cli:menu[@ref]"><xsl:text>cli.MenuRef</xsl:text></xsl:when>
    <xsl:when test="self::cli:menu">
        <xsl:call-template name="T_Error">
            <xsl:with-param name="STR_Message">
                <xsl:text>menu node should either have @name or @ref attribute.</xsl:text>
            </xsl:with-param>
        </xsl:call-template>
    </xsl:when>
    <xsl:when test="self::cli:keyword"><xsl:text>cli.Keyword</xsl:text></xsl:when>
    <xsl:when test="self::cli:param">
        <xsl:choose>
        <xsl:when test="@type='string'"><xsl:text>cli.ParamString</xsl:text></xsl:when>
        <xsl:when test="@type='int'"><xsl:text>cli.ParamInt</xsl:text></xsl:when>
        <xsl:when test="@type='float'"><xsl:text>cli.ParamFloat</xsl:text></xsl:when>
        <xsl:when test="@type='host'"><xsl:text>cli.ParamHost</xsl:text></xsl:when>
        <xsl:when test="not(@type)">
            <xsl:call-template name="T_Error">
                <xsl:with-param name="STR_Message">
                    <xsl:text>missing @type attribute</xsl:text>
                </xsl:with-param>
            </xsl:call-template>
        </xsl:when>
        <xsl:otherwise>
            <xsl:call-template name="T_Error">
                <xsl:with-param name="STR_Message">
                    <xsl:text>unknown param type '</xsl:text><xsl:value-of select="@type"/><xsl:text>'</xsl:text>
                </xsl:with-param>
            </xsl:call-template>
        </xsl:otherwise>
        </xsl:choose>
    </xsl:when>
    <xsl:when test="self::cli:endl"><xsl:text>cli.Endl</xsl:text></xsl:when>
    <xsl:when test="self::cli:tag[@id]"><xsl:text>cli.SyntaxTag</xsl:text></xsl:when>
    <xsl:when test="self::cli:tag[@ref]"><xsl:text>cli.SyntaxRef</xsl:text></xsl:when>
    <xsl:when test="self::cli:tag">
        <xsl:call-template name="T_Error">
            <xsl:with-param name="STR_Message">
                <xsl:text>tag node should either have @id or @ref attribute.</xsl:text>
            </xsl:with-param>
        </xsl:call-template>
    </xsl:when>
    <xsl:otherwise>
        <xsl:call-template name="T_Error">
            <xsl:with-param name="STR_Message">
                <xsl:text>unknown cli-node '</xsl:text><xsl:value-of select="local-name(.)"/><xsl:text>'</xsl:text>
            </xsl:with-param>
        </xsl:call-template>
    </xsl:otherwise>
    </xsl:choose>
</xsl:template>

<xsl:template name="T_Node2BlockLabel">
    <xsl:call-template name="T_Node2Var">
        <xsl:with-param name="B_UseOwnerCli" select="0"/>
    </xsl:call-template>
    <xsl:text>_lbl</xsl:text>
</xsl:template>

<xsl:template name="T_Indent0">
    <xsl:param name="STR_UserIndent" select="''"/>
    <xsl:variable name="I_Offset"><xsl:call-template name="T_IndentOffset"/></xsl:variable>
    <xsl:call-template name="T_Indent"><xsl:with-param name="STR_UserIndent" select="$STR_UserIndent"/><xsl:with-param name="I_IndentCount" select="$I_Offset + 0"/></xsl:call-template>
</xsl:template>
<xsl:template name="T_Indent1">
    <xsl:param name="STR_UserIndent" select="''"/>
    <xsl:variable name="I_Offset"><xsl:call-template name="T_IndentOffset"/></xsl:variable>
    <xsl:call-template name="T_Indent"><xsl:with-param name="STR_UserIndent" select="$STR_UserIndent"/><xsl:with-param name="I_IndentCount" select="$I_Offset + 1"/></xsl:call-template>
</xsl:template>
<xsl:template name="T_Indent2">
    <xsl:param name="STR_UserIndent" select="''"/>
    <xsl:variable name="I_Offset"><xsl:call-template name="T_IndentOffset"/></xsl:variable>
    <xsl:call-template name="T_Indent"><xsl:with-param name="STR_UserIndent" select="$STR_UserIndent"/><xsl:with-param name="I_IndentCount" select="$I_Offset + 2"/></xsl:call-template>
</xsl:template>
<xsl:template name="T_Indent3">
    <xsl:param name="STR_UserIndent" select="''"/>
    <xsl:variable name="I_Offset"><xsl:call-template name="T_IndentOffset"/></xsl:variable>
    <xsl:call-template name="T_Indent"><xsl:with-param name="STR_UserIndent" select="$STR_UserIndent"/><xsl:with-param name="I_IndentCount" select="$I_Offset + 3"/></xsl:call-template>
</xsl:template>

    <xsl:template name="T_IndentOffset">
        <xsl:choose>
        <xsl:when test="self::cli:cli">0</xsl:when>
        <xsl:when test="self::cli:menu">1</xsl:when>
        <xsl:when test="parent::cli:*"><xsl:for-each select="parent::cli:*"><xsl:call-template name="T_IndentOffset"/></xsl:for-each></xsl:when><!-- [contrib: yuhuawen, 2011, Saxon / Xalan compliance] -->
        <xsl:otherwise>0</xsl:otherwise>
        </xsl:choose>
    </xsl:template>

    <xsl:template name="T_Indent">
        <xsl:param name="STR_UserIndent" select="''"/>
        <xsl:param name="I_IndentCount" select="0"/>

        <xsl:variable name="i_IndentCount">
            <xsl:choose>
            <xsl:when test="string-length($STR_Indent) &lt;= 0"><xsl:value-of select="$I_IndentCount"/></xsl:when>
            <xsl:otherwise><xsl:value-of select="$I_IndentCount - (string-length($STR_UserIndent) div string-length($STR_Indent))"/></xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:if test="string-length($STR_UserIndent) &gt; 0">
            <xsl:value-of select="$STR_UserIndent"/>
        </xsl:if>
        <xsl:if test="$i_IndentCount &gt; 0">
            <xsl:value-of select="$STR_Indent"/>
            <xsl:call-template name="T_Indent">
                <xsl:with-param name="I_IndentCount" select="$i_IndentCount - 1"/>
            </xsl:call-template>
        </xsl:if>
    </xsl:template>

<xsl:template match="cli:java">
    <xsl:apply-templates/>
</xsl:template>

<xsl:template match="cli:value-of[@param]">
    <xsl:variable name="STR_Param" select="@param"/>
    <xsl:for-each select="ancestor::cli:param[@id=$STR_Param][position()=1]">
        <xsl:call-template name="T_Node2Var"/><xsl:text>.getValue()</xsl:text>
    </xsl:for-each>
</xsl:template>
<xsl:template match="cli:out">
    <xsl:text>getOutputStream()</xsl:text>
</xsl:template>
<xsl:template match="cli:err">
    <xsl:text>getErrorStream()</xsl:text>
</xsl:template>

<xsl:template name="T_MkJavaName">
    <xsl:param name="STR_String"/>

    <!-- Replace every special character with an underscore. -->
    <xsl:variable name="STR_SpecialChar" select="' :&lt;&gt;*|+-()#.'"/>
    <xsl:variable name="STR_SpecialMask" select="translate($STR_SpecialChar,$STR_SpecialChar,'______________________________________________')"/><!-- Note: Excess characters in the third argument of translate are ignored. -->
    <!-- Replace every accented character with its non-accented equivalent. -->
    <xsl:variable name="STR_AccentedChar" select="'áàâäçéèêëíìîïóòôöúùûü'"/>
    <xsl:variable name="STR_AccentedMask" select="'aaaaçeeeeiiiioooouuuu'"/>
    <!-- Concatenate character sequences and masks. -->
    <xsl:variable name="STR_Char"><xsl:value-of select="$STR_SpecialChar"/><xsl:value-of select="$STR_AccentedChar"/></xsl:variable>
    <xsl:variable name="STR_Mask"><xsl:value-of select="$STR_SpecialMask"/><xsl:value-of select="$STR_AccentedMask"/></xsl:variable>

    <!-- Check constants. -->
    <xsl:if test="not(string-length($STR_SpecialMask) = string-length($STR_SpecialChar))">
        <xsl:call-template name="T_Error">
            <xsl:with-param name="STR_Message">cli2java.xsl: Internal error in template T_MkCppName</xsl:with-param>
        </xsl:call-template>
    </xsl:if>

    <!-- Operate translation. -->
    <xsl:value-of select="translate($STR_String,$STR_Char,$STR_Mask)"/>
</xsl:template>

<xsl:template name="T_Error">
    <xsl:param name="STR_Message"/>

    <xsl:message terminate="yes">
        <xsl:text>Error: </xsl:text>
        <xsl:value-of select="$STR_Message"/>
        <xsl:value-of select="$STR_Endl"/>
    </xsl:message>
</xsl:template>

</xsl:stylesheet>

